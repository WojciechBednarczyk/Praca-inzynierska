\chapter{Implementacja}
% TO DO: DONE
Aplikacjê backendow¹ napisano w jêzyku Java z zachowaniem zasad programowania obiektowego. Podczas implementacji starano siê uwzglêdniæ dobre praktyki programowania oraz zasady czystego kodu. Obejmuj¹ one takie zagadnienia, jak nazewnictwo klas oraz metod, komentarze w kodzie czy obs³ugê b³êdów. Dobrze to przedyskutowano w pracy \cite{CleanCode}. Poszczególne komponenty aplikacji podzielono na pakiety. Opisano je w kolejnych sekcjach. Strukturê aplikacji backendowej pokazano na rysunku~\ref{fig:pakiety}~.
\begin{figure}[htb]
  \centering
	\includegraphics[width=0.4\textwidth]{rys04/podzial_na_pakiety}
	\caption{Struktura aplikacji backendowej}
  \label{fig:pakiety}
\end{figure}
% zrezygnowano z diagramu pakietów ze wzglêdu na rysunek przedstawiaj¹cy podzia³ na pakiety oraz opisane zale¿noœci pomiêdzy nimi w kolejnych sekcjach 


\section{Pakiet \texttt{controller}}
W pakiecie \texttt{controller} znajduj¹ siê restowe kontrolery odpowiedzialne za komunikacjê z zewnêtrznymi serwisami poprzez wysy³anie ¿¹dañ HTTP. Podstawowymi metodami HTTP s¹: 
\begin{itemize}
\item \texttt{GET} -- ¿¹danie dziêki któremu mo¿emy otrzymywaæ dane z serwera.
\item \texttt{POST} -- w ciele ¿¹dania przesy³ane s¹ dane (najczêœciej w formacie JSON), które nastêpnie s¹ przetwarzane przez serwer. Wykorzystywana najczêœciej, gdy na stronie internetowej znajduj¹ siê formularze.
\item \texttt{PUT} -- ¿¹danie pozwalaj¹ce na aktualizacjê danego zasobu na serwerze.
\item \texttt{DELETE} -- ¿¹danie u¿ywane do usuwania zasobu na serwerze.
\end{itemize} 

Dziêki Spring Boot tworzenie kontrolerów w Javie jest bardzo proste. Aby klasa sta³a siê kontrolerem nale¿y oznaczyæ j¹ anotacj¹ \texttt{@RestController}. Na listingu ~\ref{lst:kontroler} przedstawiono kod przyk³adowego kontrolera. Sama klasa oznaczona jest jeszcze anotacjami: \texttt{@CrossOrigin} -- zezwalaj¹c¹ na wykonywanie asynchronicznych zapytañ HTTP do serwisów pod innym adreseml \texttt{@RequiredArgsConstructor} -- tworz¹c¹ konstruktor z polami oznaczonymi jako \texttt{final}, co pozwala na automatyczne wstrzykiwanie zale¿noœci springowych (w tym przypadku \texttt{MessageService}) oraz \texttt{@RequestMapping} -- przyjmuj¹c¹ jako argument œcie¿kê, pod któr¹ bêdzie dostêpne projektowanie API. Metody oznaczone s¹ anotacjami \texttt{@Mapping} z~przedrostkiem oznaczaj¹cym metodê HTTP, np.~\texttt{@PostMapping} okreœlaj¹, jakie ¿¹dania mo¿na wykonywaæ na danej metodzie. Ponadto anotacja \texttt{@PreAuthorize} definiuje sposób dostêpu do metody. Wiêcej szczegó³ów podano w sekcji \ref{sec:security}. Sam kontroler ma za zadanie odbieraæ ¿¹dania, natomiast dalsze przetwarzanie informacji odbywa siê w serwisach.

\begin{lstlisting}[language=Java,style=JavaStyle,caption=Kod Ÿród³owy klasy \texttt{MessageController}, label=lst:kontroler]
@CrossOrigin(origins = "http://localhost:4200", maxAge = 3600, allowCredentials = "true")
@RestController
@RequiredArgsConstructor
@RequestMapping(value = "/api/auth")
public class MessageControler {

    private final MessageService messageService;

    @PostMapping("/message")
    @PreAuthorize("hasRole('ROLE_MENTEE') or hasRole('ROLE_PERSONAL_TRAINER')")
    public ResponseEntity postMessage(
            @RequestBody MessageDto messageDto) {

        messageService.saveMessage(messageDto);

        return ResponseEntity.ok(HttpStatus.OK);
    }

    @GetMapping("/messages")
    @ResponseBody
    @PreAuthorize("hasRole('ROLE_MENTEE') or hasRole('ROLE_PERSONAL_TRAINER')")
    public List<MessageWithSenderDto> getMessages(@RequestParam Integer userId) {
        return messageService.getUserMessages(userId);
    }
}

\end{lstlisting}

\section{pakiet \texttt{dto}}
W tym pakiecie znajduj¹ siê klasy definiuj¹ce obiekty DTO. Obiekty DTO to obiekty, które s¹ przesy³ane poza logikê biznesow¹ aplikacji, np.\ do frontendu. Zawieraj¹ one tylko te pola, które programista chce udostêpniæ poza aplikacj¹. Dziêki takiemu rozwi¹zaniu nie wystawiamy ca³ych obiektów mog¹cych zawieraæ poufne informacje typu: login, has³o czy adres. To w³aœnie te obiekty lub ich zbiory s¹ zwracane przez kontrolery. 

Na listingu ~\ref{lst:dto} przedstawiono przyk³adow¹ klasê DTO odpowiadaj¹c¹ klasie \texttt{User}. Klasa ta zawiera tylko pola, które chcemy wyœwietliæ na frontendzie. Nie znajdziemy tu pól z loginem, has³em czy emailem.

\begin{lstlisting}[language=Java,style=JavaStyle,caption=Kod Ÿród³owy klasy \emph{UserDto}, label=lst:dto]
@Builder
@Getter
@Setter
@AllArgsConstructor
@NoArgsConstructor
public class UserDto {

    private Integer id;

    private String firstName;

    private String secondName;

    private String location;

    private String role;
}

\end{lstlisting}

\section{Pakiet \texttt{mapper}}

Pakiet ten zawiera specjalne mappery które mapuj¹ obiekt encji na obiekty DTO i odwrotnie. Na listingu ~\ref{lst:mapper} przedstawiono przyk³adow¹ klasê mappera. Mo¿na zauwa¿yæ ¿e zosta³a oznaczona anotacj¹ \texttt{@Component}. Oznacza to, ¿e nie trzeba tworzyæ obiektu tej klasy poniewa¿ Spring robi to automatycznie. Zawiera 2 publiczne metody, które s¹ wywo³ywane przez odpowiednie serwisy. Metody te jako parametr przyjmuj¹ listê DTO lub encji i zwracaj¹ listy z odpowiednio zmapowanymi obiektami.

\begin{lstlisting}[language=Java,style=JavaStyle,caption=Kod Ÿród³owy klasy \emph{ExerciseMapper}, label=lst:mapper]
@Component
@RequiredArgsConstructor
public class ExerciseMapper {

    private final ExerciseRepository exerciseRepository;

    public List<ExerciseDto> mapExercisesToDto(List<Exercise> exercises) {
        return exercises.stream()
                .map(this::convertToDto)
                .toList();
    }

    private ExerciseDto convertToDto(Exercise exercise) {
        return ExerciseDto.builder()
                .id(exercise.getId())
                .name(exercise.getName())
                .description(exercise.getDescription())
                .muscleGroup(exercise.getMuscleGroup())
                .url(exercise.getUrl())
                .rating(exercise.getRating())
                .build();
    }

    public List<TrainingExercise> mapDtoToExercises(List<TrainingExerciseDto> trainingPlan) {
        return trainingPlan.stream()
                .map(this::convertToExercise)
                .toList();
    }

    private TrainingExercise convertToExercise(TrainingExerciseDto trainingExerciseDto) {
        return TrainingExercise.builder()
                .reps(trainingExerciseDto.getReps())
                .sets(trainingExerciseDto.getSets())
                .exercise(exerciseRepository.findById(trainingExerciseDto.getExerciseId()).get())
                .build();
    }
}

\end{lstlisting}

\section{Pakiet \texttt{model}}

Znajduj¹ siê w nim klasy encji JPA. Klasy te reprezentuj¹ encje w bazie danych i musz¹ posiadaæ bezargumentowy konstruktor. Ponadto, aby zadeklarowaæ klasê jako encjê JPA, nale¿y dodaæ anotacjê \texttt{@Entity} oraz klasa musi zawieraæ pole oznaczone anotacj¹ \texttt{@Id}. 

Na listingu ~\ref{lst:model1} przedstawiono przyk³adowy kod klasy z pakietu \texttt{model}. Oprócz wczeœniej wspomnianych anotacji zawiera ona tak¿e anotacjê \texttt{@Table}, która jako parametr przyjmuje nazwê tabeli w bazie danych maj¹cej byæ encj¹ JPA. Na polu \texttt{id} zosta³a dodana tak¿e anotacja \texttt{@GeneratedValue}, która definiuje wed³ug jakiej strategii przydzielane s¹ identyfikatory kluczy publicznych w bazie danych. Dodatkowo na polach, które maj¹ niejednoznaczne nazwy z~xpolami w bazie danych, zosta³a dodana anotacja \texttt{@Column}. Definiuje ona pole w tej klasie odpowiadaj¹ce polom w bazie danych. Ponadto, anotacjami typu \texttt{@OneToMany}, \texttt{@OneToOne} oznaczono pola definiuj¹ce zwi¹zki z innymi encjami JPA. Jako argument przyjmuje nazwê pola, pod jak¹ bêdzie zadeklarowana encja w innej klasie. 

\begin{lstlisting}[language=Java,style=JavaStyle,caption=Kod Ÿród³owy klasy \texttt{User}, label=lst:model1]
@Entity
@Table(name = "users")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "user_id")
    private Integer id;

    @Column(name = "first_name")
    private String firstName;

    @Column(name = "second_name")
    private String secondName;

    private String login;

    private String password;

    private String email;

    @Column(name = "date_of_birth")
    private Date dateOfBirth;

    private String location;

    @Enumerated(EnumType.STRING)
    private ERole role;

    @OneToMany(mappedBy = "userSender")
    private Set<Message> sendMessages;

    @OneToMany(mappedBy = "userReceiver")
    private Set<Message> receivedMessages;

    @OneToMany(mappedBy = "user")
    private Set<Training> trainings;

    @OneToOne(mappedBy = "user")
    private Mentee mentee;

    @OneToOne(mappedBy = "user")
    private PersonalTrainer personalTrainer;

    (...)
}

\end{lstlisting}

Powi¹zana encja natomiast musi zawieraæ to pole z zadeklarowan¹ wczeœniej nazw¹. Ponadto nale¿y oznaczyæ je anotacj¹ \texttt{@JoinColumn} podaj¹c jako argument podaj¹c nazwê klucza obcego. Zosta³o to przedstawione na kolejnym listingu ~\ref{lst:model2}.  

\begin{lstlisting}[language=Java,style=JavaStyle,caption=Kod Ÿród³owy klasy \emph{Post}, label=lst:model2]
@Entity
@Table(name = "trainings")
public class Training {

    (...)

    @ManyToOne
    @JoinColumn(name = "user_id", nullable = false)
    private User user;
}

\end{lstlisting}

\section{Pakiet \texttt{repository}}

Pakiet ten zawiera repozytoria JPA, które wykonuj¹ operacje na bazie danych. Repozytoria te s¹ interfejsami rozszerzaj¹cymi interfejs \texttt{JpaRepository} z pakietu Spring Data JPA. Interfejsy te s¹ sparametryzowane dwoma parametrami. Pierwszy z nich okreœla typ encji przechowywanej w repozytorium, natomiast drugi okreœla typ identyfikatora encji. \texttt{JpaRepository} udostêpnia metody dla operacji typu CRUD. Dla operacji, których repozytorium nie udostêpnia domyœlnie, nale¿y zadeklarowaæ w³asne metody. Tworzy siê je poprzez ³¹czenie nazwy akcji oraz pól encji.

Na listingu ~\ref{lst:repository} przedstawiono zaimplementowany fragment kodu repozytorium. W przypadku operacji szukania konkretnej encji, repozytorium zwraca typ \texttt{Optional} mog¹cy przechowywaæ znalezion¹ encjê lub wartoœæ \texttt{null} w przypadku, gdy nie znaleziono encji w bazie danych. Repozytoria oznaczone s¹ anotacjami \texttt{@Repository}.

\begin{lstlisting}[language=Java,style=JavaStyle,caption=Kod Ÿród³owy interfejsu UserRepository, label=lst:repository]
@Repository
public interface UserRepository extends JpaRepository<User, Integer> {

    Optional<User> findByLogin(String login);

    Optional<User> findById(Integer id);

    Boolean existsByLogin(String login);

    Boolean existsByEmail(String email);

    List<User> findByFirstNameOrSecondNameOrLocation(String firstName, String secondName, String location);
}

\end{lstlisting}

\section{Pakiet \texttt{security}}
\label{sec:security}
W pakiecie tym znajduj¹ siê klasy odpowiedzialne za autoryzacje i uwierzytelnianie w projektowanej aplikacji. Uwierzytelnianie to weryfikacja to¿samoœci u¿ytkownika. W projektowanej aplikacji odbywa siê poprzez podanie loginu i has³a. Autoryzacja natomiast, to nadanie odpowiednich uprawnieñ do korzystania z aplikacji. W aplikacji skorzystano z JWT który przechowywany jest w plikach Cookie. JWT jest otwartym standardem, który pozwala na wymianê danych miêdzy dwoma stronami. Przekazywane dane s¹ zakodowane. Wykorzystywany jest przede wszystkim do autoryzacji aplikacji. Struktura JWT sk³ada siê z trzech elementów: nag³ówka, zawartoœci oraz sygnatury. W projektowanej aplikacji w JWT przechowywana bêdzie informacja o id u¿ytkownika oraz jego roli w systemie. 

Jedn¹ z podstawowych funkcjonalnoœci aplikacji jest mo¿liwoœæ za³o¿enia konta w systemie z odpowiedni¹ rol¹ oraz mo¿liwoœæ zalogowania siê do niego. Bez konta u¿ytkownika funkcjonalnoœæ ca³ej aplikacji jest znacznie uszczuplona. Na rysunku ~\ref{fig:autoryzacja} przedstawiono w jaki sposób tworzone jest konto u¿ytkownika oraz w jaki sposób system korzysta z JWT.

\begin{figure}[htb]
  \centering
	\includegraphics[width=0.76\textwidth]{rys04/autoryzacja}
	\caption{Wykorzystanie JWT w projektowanej aplikacji}
  \label{fig:autoryzacja}
\end{figure}

W pakiecie security znajduje siê klasa \texttt{WebSecurityConfig} odpowiedzialna za konfiguracjê Spring Security. Klasa ta musi byæ oznaczona anotacjami \texttt{@Configuration} oraz \texttt{@EnableWebSecurity}, które pozwol¹ automatycznie znaleŸæ konfiguracje przez Springa. Na listingu ~\ref{lst:webConfig} przedstawiono konfiguracjê w projektowanej aplikacji. Oprócz wczeœniej wspomnianych anotacji klasa oznaczona jest tak¿e anotacj¹ \texttt{@EnableGlobalMethodSecurity} w której ustawiany jest parametr \texttt{prePostEnabled} na wartoœæ \texttt{true}. Pozwala to na korzystanie z~anotacji \texttt{@PreAuthorize} na kontrolerach, dziêki którym autoryzacja przebiega przed wywo³aniem metody.

W klasie mo¿na wyró¿niæ beany \texttt{PasswordEncoder}, \texttt{SecurityFilterChain} oraz \texttt{DaoAuthenticationProvider}. \texttt{PasswordEncoder} zwraca implementacjê enkodera has³a korzystaj¹cego z funkcji hashuj¹cej Bcrypt. \texttt{SecurityFilterChain} odpowiada za skonfigurowanie filtra. Wszystkie ¿¹dania przychodz¹ce do aplikacji pocz¹tkowo przechodz¹ przez filtr, po czym je¿eli ¿¹danie przesz³o przez filtr przeprowadzana jest w³aœciwa obs³uga ¿¹dania. \texttt{DaoAuthenticationProvider} ustawia enkoder has³a oraz serwis odpowiedzialny za dostarczanie informacji o u¿ytkowniku.

\begin{lstlisting}[language=Java,style=JavaStyle,caption=Kod Ÿród³owy klasy \emph{WebSecurityConfig}, label=lst:webConfig]
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(
        prePostEnabled = true)
public class WebSecurityConfig {

    (...)

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.cors().and().csrf().disable()
                .exceptionHandling().authenticationEntryPoint(unauthorizedHandler).and()
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS).and()
                .authorizeRequests().antMatchers("/api/auth/**").permitAll()
                .antMatchers("/api/test/**").permitAll()
                .antMatchers("/api/exercises/**").permitAll()
                .anyRequest().authenticated();

        http.authenticationProvider(authenticationProvider());

        http.addFilterBefore(authenticationJwtTokenFilter(), UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    (...)

    @Bean
    public DaoAuthenticationProvider authenticationProvider() {
        DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();

        authProvider.setUserDetailsService(userDetailsService);
        authProvider.setPasswordEncoder(passwordEncoder());

        return authProvider;
    }

    (...)
}
\end{lstlisting}

W pakiecie \texttt{security} znajduje siê tak¿e klasa \texttt{JwtUtils}, która dostarcza metod do generowania, parsowania z cookie oraz walidacji JWT. W pliku \texttt{application.properties} ustawiono 3 wartoœci odnosz¹ce siê do tego pod jak¹ nazw¹ zapisywany bêdzie JWT, na podstawie jakiego klucza bêdzie szyfrowany JWT oraz jak d³ugo JWT bêdzie aktywny.

\section{Service}

W tym pakiecie zawarta jest ca³a logika biznesowa aplikacji. Znajduj¹ siê w nim serwisy oznaczone anotacjami \texttt{@Service} dziêki czemu s¹ tworzone automatycznie przez kontekst aplikacji Springa. Do nich przekazywane s¹ dane odbierane przez kontrolery. Nastêpnie korzystaj¹ z mapperów, repozytoriów lub innych serwisów przetwarzaj¹c dane. 

Na listingu ~\ref{lst:service} przedstawiono przyk³adowy serwis z projektowanej aplikacji odpowiedzialny za przetwarzanie informacji zwi¹zanych z æwiczeniami. Zawiera on jedn¹ metodê zwracaj¹c¹ wszystkie æwiczenia znajduj¹ce siê w bazie danych. Przed zwróceniem listy æwiczeñ do kontrolera s¹ one mapowane do postaci DTO.

\begin{lstlisting}[language=Java,style=JavaStyle,caption=Kod Ÿród³owy klasy \emph{ExerciseService}, label=lst:service]
@Service
@RequiredArgsConstructor
public class ExerciseService {

    private final ExerciseRepository exerciseRepository;

    private final ExerciseMapper exerciseMapper;

    public List<ExerciseDto> findAll() {
        List<Exercise> exercises = exerciseRepository.findAll();
        return exerciseMapper.mapExercisesToDto(exercises);
    }
}

\end{lstlisting}

\section{Diagram ERD}
Na rysunku~\ref{fig:diagramERD} przedstawiono diagram ERD projektowanej aplikacji.
\begin{figure}[b]
  \centering
\includegraphics[width=.83\textwidth]{rys04/diagramERD}
  \caption{Diagram ERD}
  \label{fig:diagramERD}
\end{figure} 
Mo¿na na nim wyró¿niæ tabelê \texttt{USERS} która jest jedn¹ z g³ównych tabel w systemie. Odpowiedzialna jest za przechowywanie informacji o kontach u¿ytkowników. Oprócz tej tabeli mo¿na wyró¿niæ tak¿e tabele \texttt{MENTEES} oraz \texttt{PERSONAL\_TRAINERS} które równie¿ przechowuj¹ informacje o u¿ytkowniku, jednak jest to zale¿ne od roli w systemie. Pozosta³e tabele zawieraj¹ informacje o wiadomoœciach miêdzy u¿ytkownikami, planach treningowach czy opiniach o trenerze.


